<!DOCTYPE html>
<meta charset="UTF-8"> 


<!-- <script src="js/numjs/dist/numjs.min.js"></script> -->
<script src="js/numeric-1.2.6.js"></script>
<!-- <script src="js/numjs_test.js"></script> -->

<html>

<body>

<h1>My First Heading</h1>

<p id="demo"></p>

<script>

// Functions

// Define a square function for root-finding
sqr = function(x) { return x*x; };

// Define a rounding function for display precision
round = function(x,n) { return Math.round(Math.pow(10,n)*x)/Math.pow(10,n); }; 

// Function to be solved to find steady state labor
l_fun = function(x) { 
	return 1/phi*Math.pow((A*Math.pow(KL,alpha)-delta*KL),-sigma)*(1-alpha)*A*Math.pow(KL,alpha)- Math.pow(x,sigma)*Math.pow(1-x,-eta);
};

// Input parameter values for simulation
var rho = 0.9
var sigma = 1
var alpha = 0.33
var delta = 0.025
var beta = 0.98
var phi = 1.5
var eta = 1
var A = 1

// Compute steady state

// Capital-to-labor ratio
var KL = Math.pow(alpha*A/(Math.pow(beta,-1)+delta-1),1/(1-alpha))

// Solve for steady state labor
var L = numeric.uncmin(function(x) { return sqr(l_fun(x[0])); },[0.5]).solution

// Solve for other endogenous variables.
var K = KL*L
var Y = A*Math.pow(K,alpha)*Math.pow(L,1-alpha)
var I = delta*K
var C = Y - I

// Display the steady state
document.write("A=",round(A,5),"<br>")
document.write("L=",round(L,5),"<br>")
document.write("K=",round(K,5),"<br>")
document.write("Y=",round(Y,5),"<br>")
document.write("I=",round(I,5),"<br>")
document.write("C=",round(C,5),"<br>")
document.write("<br>")

// Compute coefficients for log-linear approximation
var GAMMA  = Math.pow(1-L,-eta)/A*Math.pow(K,-alpha)*Math.pow(L,alpha)
var PHI = 1/sigma*Math.pow(phi/(1-alpha)*Math.pow(1-L,-eta)*Math.pow(A,-1)*Math.pow(K,-alpha)*Math.pow(L,alpha),-1/sigma)

var phi_01 = beta*GAMMA*(alpha*(delta-1)-alpha*Y/K)
var phi_02 = beta*GAMMA*(eta*Math.pow(1-L,-1)*L*(alpha*Y/K+1-delta) + alpha*Y/K + alpha*(1 - delta))
var phi_03 = -alpha*GAMMA

var phi_00 = beta*GAMMA*(delta-1)
var phi_04_lhs = phi_00*rho
var phi_04_rhs = -GAMMA

var phi_04=-phi_04_lhs+phi_04_rhs
var phi_05 = GAMMA*(eta*L/(1-L)+alpha)
var phi_06 = K
var phi_08 = alpha*Y + (1-delta)*K - PHI*alpha
var phi_09 = Y - PHI
var phi_10 = PHI*(eta*Math.pow(1-L,-1)*L+alpha) + (1-alpha)*Y


document.write("GAMMA=",round(GAMMA,5),"<br>")
document.write("PHI=",round(PHI,5),"<br>")
document.write("phi_01=",round(phi_01,5),"<br>")
document.write("phi_02=",round(phi_02,5),"<br>")
document.write("phi_03=",round(phi_03,5),"<br>")
document.write("phi_04=",round(phi_04,5),"<br>")
document.write("phi_05=",round(phi_05,5),"<br>")
document.write("phi_06=",round(phi_06,5),"<br>")
document.write("phi_08=",round(phi_08,5),"<br>")
document.write("phi_09=",round(phi_09,5),"<br>")
document.write("phi_10=",round(phi_10,5),"<br>")
document.write("<br>")


//Compute solution coefficients
var gamma_03_poly_a = phi_06**-1*phi_02*phi_10
var gamma_03_poly_b = phi_06**-1*(phi_01*phi_10+phi_02*phi_08)-phi_05
var gamma_03_poly_c = phi_06**-1*phi_01*phi_08-phi_03

var roots = [(-gamma_03_poly_b+Math.sqrt(Math.pow(gamma_03_poly_b,2)-4*gamma_03_poly_a*gamma_03_poly_c))/2/gamma_03_poly_a,(-gamma_03_poly_b-Math.sqrt(Math.pow(gamma_03_poly_b,2)-4*gamma_03_poly_a*gamma_03_poly_c))/2/gamma_03_poly_a]

document.write("roots[0]=",round(roots[0],5),"<br>")
document.write("k_coeff =",phi_06**-1*(phi_08+phi_10*roots[0]),"<br>")
document.write("roots[1]=",round(roots[1],5),"<br>")
document.write("k_coeff =",phi_06**-1*(phi_08+phi_10*roots[1]),"<br>")
document.write("<br>")

if (phi_06**-1*(phi_08+phi_10*roots[0]) >1 && phi_06**-1*(phi_08+phi_10*roots[1]) < 1 ) {

	var gamma_03 = roots[1]
	var gamma_01 = Math.pow(phi_06,-1)*(phi_08+phi_10*gamma_03)

	var gamma_04 = (phi_04-Math.pow(phi_06,-1)*(phi_02*gamma_03*phi_09 + phi_01*phi_09))/(Math.pow(phi_06,-1)*(phi_01*phi_10+phi_02*gamma_03*phi_10)+phi_02*rho-phi_05 )
	var gamma_02 = Math.pow(phi_06,-1)*(phi_09+phi_10*gamma_04)

	document.write("gamma_01=",round(gamma_01,5),"<br>")
	document.write("gamma_02=",round(gamma_02,5),"<br>")
	document.write("gamma_03=",round(gamma_03,5),"<br>")
	document.write("gamma_04=",round(gamma_04,5),"<br>")
	document.write("<br>")

} else if (phi_06**-1*(phi_08+phi_10*roots[0]) <1 && phi_06**-1*(phi_08+phi_10*roots[1]) > 1 ) {

	var gamma_03 = roots[0]
	var gamma_01 = phi_06**-1*(phi_08+phi_10*gamma_03)

	var gamma_04 = (phi_04-Math.pow(phi_06,-1)*(phi_02*gamma_03*phi_09 + phi_01*phi_09))/(Math.pow(phi_06,-1)*(phi_01*phi_10+phi_02*gamma_03*phi_10)+phi_02*rho-phi_05 )
	var gamma_02 = Math.pow(phi_06,-1)*(phi_09+phi_10*gamma_04)

	document.write("gamma_01=",round(gamma_01,5),"<br>")
	document.write("gamma_02=",round(gamma_02,5),"<br>")
	document.write("gamma_03=",round(gamma_03,5),"<br>")
	document.write("gamma_04=",round(gamma_04,5),"<br>")
	document.write("<br>")

} else if  (phi_06**-1*(phi_08+phi_10*roots[0]) <1 && phi_06**-1*(phi_08+phi_10*roots[1]) < 1 ) {
	
	window.alert('Too many stable solutions')

} else { (phi_06**-1*(phi_08+phi_10*roots[0]) >=1 && phi_06**-1*(phi_08+phi_10*roots[1]) >= 1 )
	
	window.alert('No stable solutions')
}

tme=[0];
eProc = [0];
aProc = [0];
var stochSim = document.getElementById ("stochSim");
if (periods <minForMarkers ) {
    var enableMarks = true
}
else {
    var enableMarks = false
}

if (stochSim.checked == true) {
    for (i = 1; i <= periods; i++) {
        tme.push(i);
        e = random.normal(0,1);
        eProc.push(sigA*e);
        aProc.push(rhoA*aProc[aProc.length-1] + sigA*e);
        
    eProc[0] = Math.NaN
    }
} else {
    tme.push(1)
    eProc.push(sigA);
    xProc.push(rhoA*aProc[aProc.length-1] + sigA);
    for (i = 2; i <= periods; i++) {
        tme.push(i);
        e = 0;
        eProc.push(sigA*e);
        xProc.push(rhoA*aProc[aProc.length-1] + sigA*e);
    }
}

console.log(stochSim.checked)
document.write("TFP=",round(aProc,5),"<br>")

</script>

</body>
</html>
